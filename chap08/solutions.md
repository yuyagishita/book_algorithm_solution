# 8.1 o

計算量は O(N)である。N 個の node を順番にみるため。

# 8.2 o

計算量は O(N^2)。連結リストの i 番目を取得する処理は O(N)で、それを for 文でそれぞれみるため。

## 解説見た

厳密には N(N+1)/2 の計算時間になる。get(i)は i が大きくなるにつれて計算量が増える。

# 8.3 o

連結リストの操作をする際にサイズをカウントしておけば O(1)でサイズを取得できる。

# 8.4 o

削除対象のノードの前後がわからないと削除後のポインタができないので、まず O(N)で前から 3 つ分のノードを保持する。
2 つ目のノードが対象ノードになったら対象ノードの削除、対象ノードの前後のポインタを繋ぎ直す。
よって、計算量は O(N)で解ける。

# 8.5 o

O(N+M)ってことは 2 重 for とかソートとかそういうのはできない。
今回は以下計算量が発生して O(N+M+M+1)になり、係数などは無視するので O(N+M)になる。

- ハッシュテーブルに入力値を入れる処理が O(N)
- 配列に入力値を入れる処理が O(M)
- for で配列をそれぞれ確認するのが O(M)
- ハッシュテーブルの値の検索は O(1)

# 8.6 △

簡単に実装すると 2 重 for で O(N^2)になる。
添字を使うってことは配列でデータを持つのは必須。
回答の冒頭をチラ見してしまったので △ にしている。

## 解説見た

連想配列の中に{a[i]の値: 添字 i の配列}にすることでどの添字が対応しているかを自分は作った。

# 8.7 o

list と set を使って解けそう。a+b=k になる値があるか判定する。
b=k-a にして b を set にして k-a に該当する値があるか調べる。
a の list を回すための for だけの O(N)で解ける。
いや、それぞれの組み合わせごとに k にできるかどうかを判定するらしい。
となると連想配列が必要になる。
