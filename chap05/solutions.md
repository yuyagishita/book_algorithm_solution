# 5.1 x
動的計画法むずいわ。

## 解説見た
dp[i][w]でiは何日目かを入れて、wはabcどの選択肢をとったのかを入れる。
で遷移はdp[i]→dp[i+1]の遷移はi日目に何を選んだかで決まる。
要は前日にaを選んだら、次の日はb or cが入る。2 * 3通りある。

# 5.2 x
部分和問題。今まではbit全探索と再帰関数、メモ再起で解いた問題。
それをDPでとく。dp[i][w]でiがN個の整数のi番目を含むで、wは0~Wが含まれているか。

## 解説見た
ナップザック問題と同じ考え方で解ける。

# 5.3 o
5.2の応用みたいな問題。

# 5.4 x
部分和問題の発展。
k個を選択して総和をwにする問題。
bool値じゃなくて違う情報を持たせる必要がある。

## 解説見た
> dp[i][j] ← 最初のi個の整数の中からいくつか選んだ総和がjにする方法のうち、選ぶ整数の個数の最小値

jのそれぞれの値を作成するときの最小個数がわかればwの時の個数もわかる。その値がkに等しければOK。  
dpの初期値設定に気をつける。

# 5.5 x
全然わかんない。

## 解説見た
dp[i+1][j-a[i]]を遷移条件に入れることでa[i]を何回でも使えるようになる。

# 5.6 x
これもよくわからん。
難易度星4の問題は初見だと厳しいな。

## 解説見た
dp[i][j]で最初のi番目の個数を使ってjの値を作った時にiを何個使ったかを保存する。
そうすれば各個数の時に何個使ってできたかがわかるので、次のjを作る時に差分から求める感じになる。
うまく言葉がまとまっていない感じがする。

# 5.7 x
文字列S, Tが与えられる。部分文字列の最長を求める問題。
dp[i][j]でiはSの最初のi文字目までを使う。jも同様な感じで使う。
abcd, abce 

## 解説見た
DPをどうやって定義するか、どうやって緩和するかの考え方を理解できていないと応用ができない。復元するにはどういう遷移を辿ったのかを考えて逆に戻ればいい。
今回のケースだとテーブルが+1されたところまで戻ってSとTが同じかどうかのチェックをすればいい。

# 5.8 x
## 解説見た
区間分け問題なんとなくはわかった。
[j,i)の処理ができればあとはその値に沿って計算すればいい。

数回とかないと理解して自分のものにできなさそう。
