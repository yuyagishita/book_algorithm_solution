# 3.1 o
`a = [1, 3, 4, 3, 7, 9, 3], v = 3`で考えてみる。
breakされないってことは`a[i]=v`があった時に添え字を更新する。
for文によってaの配列要素すべてを参照するので、
添え字の更新は1, 3, 6になる。よって最大のものが格納されているよねって感じ。

# 3.2 o
素直に計算する

# 3.3 o
この問題は1番小さい数字を常に記録する。
もし次に判別する値が1番小さい数字よりも小さかったら、今までも持ってた数字を2番目に入れる。
で1番目を更新する。
で1番目が更新できないけど、2番目は更新できるとき素直にやる。

# 3.4 o
整数の中から2つ取り出してその差が1番大きい組み合わせを出してその差を出力せよとのこと。
最小値と最大値を記録して引き算するだけ。


# 3.5 o
この問題は与えられた整数すべてに対して2で何回われるのかを調べる。
ということは2で割れる回数が少ないボトルネックとなっている整数を調査すればよし。

# 3.6 o
シンプルに全探索をする。forを3つ入れはしない。
$X+Y+Z=N$は変換すると$N-X-Y=Z$を利用する。
$Z<=K and Z>0$には注意。

# 3.7 x
これは文字列の間にプラスを入れるかどうかのBit全探索をすればOKかな。ヒントを見てしまった。。
bit全探索の実装をしてから足算のところがうまくできなかった。。

解法としては、2^nケースあるそれぞれに対して、プラスを途中に含むか判定を入れて文字列を作成する。
それを'+'で分割してmapに変更後全部たす。
